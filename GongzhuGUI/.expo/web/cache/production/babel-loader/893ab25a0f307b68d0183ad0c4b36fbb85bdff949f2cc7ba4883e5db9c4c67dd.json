{"ast":null,"code":"\"use strict\";import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _objectWithoutProperties from\"@babel/runtime/helpers/objectWithoutProperties\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";var _excluded=[\"screen\",\"if\"],_excluded2=[\"screens\",\"groups\"],_excluded3=[\"if\"];function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}import*as React from'react';import{isValidElementType}from'react-is';import{useRoute}from\"./useRoute.js\";import{jsx as _jsx}from\"react/jsx-runtime\";import{createElement as _createElement}from\"react\";var MemoizedScreen=React.memo(function(_ref){var component=_ref.component;var route=useRoute();var children=React.createElement(component,{route:route});return children;});MemoizedScreen.displayName='Memo(Screen)';var getItemsFromScreens=function getItemsFromScreens(Screen,screens){return Object.entries(screens).map(function(_ref2){var _ref3=_slicedToArray(_ref2,2),name=_ref3[0],item=_ref3[1];var component;var props={};var useIf;var isNavigator=false;if('screen'in item){var screen=item.screen,_if=item.if,rest=_objectWithoutProperties(item,_excluded);useIf=_if;props=rest;if(isValidElementType(screen)){component=screen;}else if('config'in screen){isNavigator=true;component=createComponentForStaticNavigation(screen,`${name}Navigator`);}}else if(isValidElementType(item)){component=item;}else if('config'in item){isNavigator=true;component=createComponentForStaticNavigation(item,`${name}Navigator`);}if(component==null){throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);}var element=isNavigator?(React.createElement(component,{})):_jsx(MemoizedScreen,{component:component});return function(){var shouldRender=useIf==null||useIf();if(!shouldRender){return null;}return _jsx(Screen,_objectSpread(_objectSpread({name:name},props),{},{children:function children(){return element;}}),name);};});};export function createComponentForStaticNavigation(tree,displayName){var Navigator=tree.Navigator,Group=tree.Group,Screen=tree.Screen,config=tree.config;var screens=config.screens,groups=config.groups,rest=_objectWithoutProperties(config,_excluded2);if(screens==null&&groups==null){throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");}var items=[];for(var key in config){if(key==='screens'&&screens){items.push.apply(items,_toConsumableArray(getItemsFromScreens(Screen,screens)));}if(key==='groups'&&groups){items.push.apply(items,_toConsumableArray(Object.entries(groups).map(function(_ref5){var _ref6=_slicedToArray(_ref5,2),key=_ref6[0],_ref4=_ref6[1];var useIf=_ref4.if,group=_objectWithoutProperties(_ref4,_excluded3);var groupItems=getItemsFromScreens(Screen,group.screens);return function(){var children=groupItems.map(function(item){return item();});var shouldRender=useIf==null||useIf();if(!shouldRender){return null;}return _createElement(Group,_objectSpread(_objectSpread({navigationKey:key},group),{},{key:key}),children);};})));}}var NavigatorComponent=function NavigatorComponent(){var children=items.map(function(item){return item();});return _jsx(Navigator,_objectSpread(_objectSpread({},rest),{},{children:children}));};NavigatorComponent.displayName=displayName;return NavigatorComponent;}export function createPathConfigForStaticNavigation(tree,options,auto){var initialScreenConfig;var _createPathConfigForTree=function createPathConfigForTree(t,o,skipInitialDetection){var createPathConfigForScreens=function createPathConfigForScreens(screens,initialRouteName){return Object.fromEntries(Object.entries(screens).sort(function(_ref7,_ref8){var _ref9=_slicedToArray(_ref7,1),a=_ref9[0];var _ref10=_slicedToArray(_ref8,1),b=_ref10[0];if(a===initialRouteName){return-1;}if(b===initialRouteName){return 1;}return 0;}).map(function(_ref11){var _ref12=_slicedToArray(_ref11,2),key=_ref12[0],item=_ref12[1];var screenConfig={};if('linking'in item){if(typeof item.linking==='string'){screenConfig.path=item.linking;}else{Object.assign(screenConfig,item.linking);}if(typeof screenConfig.path==='string'){screenConfig.path=screenConfig.path.replace(/^\\//,'').replace(/\\/$/,'');}}var screens;var skipInitialDetectionInChild=skipInitialDetection||screenConfig.path!=null&&screenConfig.path!=='';if('config'in item){screens=_createPathConfigForTree(item,undefined,skipInitialDetectionInChild);}else if('screen'in item&&'config'in item.screen&&(item.screen.config.screens||item.screen.config.groups)){screens=_createPathConfigForTree(item.screen,undefined,skipInitialDetectionInChild);}if(screens){screenConfig.screens=screens;}if(auto&&!screenConfig.screens&&!('linking'in item&&item.linking==null)){if(screenConfig.path!=null){if(!skipInitialDetection&&screenConfig.path===''){initialScreenConfig=undefined;}}else{if(!skipInitialDetection&&initialScreenConfig==null){initialScreenConfig=screenConfig;}screenConfig.path=key.replace(/([A-Z]+)/g,'-$1').replace(/^-/,'').toLowerCase();}}return[key,screenConfig];}).filter(function(_ref13){var _ref14=_slicedToArray(_ref13,2),screen=_ref14[1];return Object.keys(screen).length>0;}));};var screens={};for(var key in t.config){if(key==='screens'&&t.config.screens){var _o$initialRouteName;Object.assign(screens,createPathConfigForScreens(t.config.screens,(_o$initialRouteName=o==null?void 0:o.initialRouteName)!=null?_o$initialRouteName:t.config.initialRouteName));}if(key==='groups'&&t.config.groups){Object.entries(t.config.groups).forEach(function(_ref15){var _o$initialRouteName2;var _ref16=_slicedToArray(_ref15,2),group=_ref16[1];Object.assign(screens,createPathConfigForScreens(group.screens,(_o$initialRouteName2=o==null?void 0:o.initialRouteName)!=null?_o$initialRouteName2:t.config.initialRouteName));});}}if(Object.keys(screens).length===0){return undefined;}return screens;};var screens=_createPathConfigForTree(tree,options,false);if(auto&&initialScreenConfig){initialScreenConfig.path='';}return screens;}","map":{"version":3,"names":["React","isValidElementType","useRoute","jsx","_jsx","createElement","_createElement","MemoizedScreen","memo","_ref","component","route","children","displayName","getItemsFromScreens","Screen","screens","Object","entries","map","_ref2","_ref3","_slicedToArray","name","item","props","useIf","isNavigator","screen","_if","if","rest","_objectWithoutProperties","_excluded","createComponentForStaticNavigation","Error","element","shouldRender","_objectSpread","tree","Navigator","Group","config","groups","_excluded2","items","key","push","apply","_toConsumableArray","_ref5","_ref6","_ref4","group","_excluded3","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","options","auto","initialScreenConfig","createPathConfigForTree","t","o","skipInitialDetection","createPathConfigForScreens","initialRouteName","fromEntries","sort","_ref7","_ref8","_ref9","a","_ref10","b","_ref11","_ref12","screenConfig","linking","path","assign","replace","skipInitialDetectionInChild","undefined","toLowerCase","filter","_ref13","_ref14","keys","length","_o$initialRouteName","forEach","_ref15","_o$initialRouteName2","_ref16"],"sources":["/Users/yuezhang/Documents/projects/gongzhu/GongzhuGUI/node_modules/@react-navigation/core/src/StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport type {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  NavigationListBase,\n  NavigatorScreenParams,\n  NavigatorTypeBagBase,\n  PathConfig,\n  RouteConfigComponent,\n  RouteConfigProps,\n  RouteGroupConfig,\n} from './types';\nimport { useRoute } from './useRoute';\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype KeysOf<T> = T extends {} ? keyof T : never;\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\n\ntype ParamsForScreenComponent<T> = T extends {\n  screen: React.ComponentType<{ route: { params: infer P } }>;\n}\n  ? P\n  : T extends React.ComponentType<{ route: { params: infer P } }>\n    ? P\n    : undefined;\n\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\n  : T extends StaticNavigation<any, any, any>\n    ? NavigatorScreenParams<StaticParamList<T>> | undefined\n    : UnknownToUndefined<ParamsForScreenComponent<T>>;\n\ntype ParamListForScreens<Screens> = {\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\n};\n\ntype ParamListForGroups<\n  Groups extends\n    | Readonly<{\n        [key: string]: {\n          screens: StaticConfigScreens<\n            ParamListBase,\n            NavigationState,\n            {},\n            EventMapBase,\n            any\n          >;\n        };\n      }>\n    | undefined,\n> = Groups extends {\n  [key: string]: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      any\n    >;\n  };\n}\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\n  : {};\n\ntype StaticRouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigation,\n> = RouteConfigProps<\n  ParamList,\n  RouteName,\n  State,\n  ScreenOptions,\n  EventMap,\n  Navigation\n> &\n  RouteConfigComponent<ParamList, RouteName>;\n\ntype StaticConfigScreens<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = {\n  [RouteName in keyof ParamList]:\n    | React.ComponentType<any>\n    | StaticNavigation<any, any, any>\n    | (Omit<\n        StaticRouteConfig<\n          ParamList,\n          RouteName,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList[RouteName]\n        >,\n        'name' | 'component' | 'getComponent' | 'children'\n      > & {\n        /**\n         * Callback to determine whether the screen should be rendered or not.\n         * This can be useful for conditional rendering of screens,\n         * e.g. - if you want to render a different screen for logged in users.\n         *\n         * You can use a custom hook to use custom logic to determine the return value.\n         *\n         * @example\n         * ```js\n         * if: useIsLoggedIn\n         * ```\n         */\n        if?: () => boolean;\n        /**\n         * Linking config for the screen.\n         * This can be a string to specify the path, or an object with more options.\n         *\n         * @example\n         * ```js\n         * linking: {\n         *   path: 'profile/:id',\n         *   exact: true,\n         * },\n         * ```\n         */\n        linking?: PathConfig<ParamList> | string;\n        /**\n         * Static navigation config or Component to render for the screen.\n         */\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\n      });\n};\n\ntype GroupConfig<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = Omit<\n  RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>,\n  'screens' | 'children'\n> & {\n  /**\n   * Callback to determine whether the screens in the group should be rendered or not.\n   * This can be useful for conditional rendering of group of screens.\n   */\n  if?: () => boolean;\n  /**\n   * Static navigation config or Component to render for the screen.\n   */\n  screens: StaticConfigScreens<\n    ParamList,\n    State,\n    ScreenOptions,\n    EventMap,\n    NavigationList\n  >;\n};\n\nexport type StaticConfig<Bag extends NavigatorTypeBagBase> =\n  StaticConfigInternal<\n    Bag['ParamList'],\n    Bag['NavigatorID'],\n    Bag['State'],\n    Bag['ScreenOptions'],\n    Bag['EventMap'],\n    Bag['NavigationList'],\n    Bag['Navigator']\n  >;\n\ntype StaticConfigInternal<\n  ParamList extends ParamListBase,\n  NavigatorID extends string | undefined,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n  Navigator extends React.ComponentType<any>,\n> = Omit<\n  Omit<\n    React.ComponentProps<Navigator>,\n    keyof DefaultNavigatorOptions<\n      ParamListBase,\n      string | undefined,\n      NavigationState,\n      {},\n      EventMapBase,\n      NavigationList[keyof ParamList]\n    >\n  > &\n    DefaultNavigatorOptions<\n      ParamList,\n      NavigatorID,\n      State,\n      ScreenOptions,\n      EventMap,\n      NavigationList[keyof ParamList]\n    >,\n  'screens' | 'children'\n> &\n  (\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups?: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens?: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n  );\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\n  route: {\n    params: T;\n  };\n};\n\n/**\n * Infer the param list from the static navigation config.\n */\nexport type StaticParamList<\n  T extends {\n    readonly config: {\n      readonly screens?: Record<string, any>;\n      readonly groups?: {\n        [key: string]: {\n          screens: Record<string, any>;\n        };\n      };\n    };\n  },\n> = FlatType<\n  ParamListForScreens<T['config']['screens']> &\n    ParamListForGroups<T['config']['groups']>\n>;\n\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\n  Navigator: React.ComponentType<NavigatorProps>;\n  Group: React.ComponentType<GroupProps>;\n  Screen: React.ComponentType<ScreenProps>;\n  config: StaticConfig<NavigatorTypeBagBase>;\n};\n\nconst MemoizedScreen = React.memo(\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\n    const route = useRoute();\n    const children = React.createElement(component, { route });\n\n    return children;\n  }\n);\n\nMemoizedScreen.displayName = 'Memo(Screen)';\n\nconst getItemsFromScreens = (\n  Screen: React.ComponentType<any>,\n  screens: StaticConfigScreens<any, any, any, any, any>\n) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component: React.ComponentType<any> | undefined;\n    let props: {} = {};\n    let useIf: (() => boolean) | undefined;\n\n    let isNavigator = false;\n\n    if ('screen' in item) {\n      const { screen, if: _if, ...rest } = item;\n\n      useIf = _if;\n      props = rest;\n\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(\n          screen,\n          `${name}Navigator`\n        );\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n\n    if (component == null) {\n      throw new Error(\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n      );\n    }\n\n    const element = isNavigator ? (\n      React.createElement(component, {})\n    ) : (\n      <MemoizedScreen component={component} />\n    );\n\n    return () => {\n      const shouldRender = useIf == null || useIf();\n\n      if (!shouldRender) {\n        return null;\n      }\n\n      return (\n        <Screen key={name} name={name} {...props}>\n          {() => element}\n        </Screen>\n      );\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(\n  tree: StaticNavigation<any, any, any>,\n  displayName: string\n): React.ComponentType<{}> {\n  const { Navigator, Group, Screen, config } = tree;\n  const { screens, groups, ...rest } = config;\n\n  if (screens == null && groups == null) {\n    throw new Error(\n      \"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\"\n    );\n  }\n\n  const items: (() => React.JSX.Element | null)[] = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n\n    if (key === 'groups' && groups) {\n      items.push(\n        ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\n          const groupItems = getItemsFromScreens(Screen, group.screens);\n\n          return () => {\n            // Call unconditionally since screen configs may contain `useIf` hooks\n            const children = groupItems.map((item) => item());\n\n            const shouldRender = useIf == null || useIf();\n\n            if (!shouldRender) {\n              return null;\n            }\n\n            return (\n              <Group navigationKey={key} {...group} key={key}>\n                {children}\n              </Group>\n            );\n          };\n        })\n      );\n    }\n  }\n\n  const NavigatorComponent = () => {\n    const children = items.map((item) => item());\n\n    return <Navigator {...rest}>{children}</Navigator>;\n  };\n\n  NavigatorComponent.displayName = displayName;\n\n  return NavigatorComponent;\n}\n\ntype TreeForPathConfig = {\n  config: {\n    initialRouteName?: string;\n    screens?: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      Record<string, unknown>\n    >;\n    groups?: {\n      [key: string]: {\n        screens: StaticConfigScreens<\n          ParamListBase,\n          NavigationState,\n          {},\n          EventMapBase,\n          Record<string, unknown>\n        >;\n      };\n    };\n  };\n};\n\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(\n  tree: TreeForPathConfig,\n  options?: {\n    initialRouteName?: string;\n  },\n  auto?: boolean\n) {\n  let initialScreenConfig: PathConfig<ParamListBase> | undefined;\n\n  const createPathConfigForTree = (\n    t: TreeForPathConfig,\n    o: { initialRouteName?: string } | undefined,\n    // If a screen is a leaf node, but inside a screen with path,\n    // It should not be used for initial detection\n    skipInitialDetection: boolean\n  ) => {\n    const createPathConfigForScreens = (\n      screens: StaticConfigScreens<\n        ParamListBase,\n        NavigationState,\n        {},\n        EventMapBase,\n        Record<string, unknown>\n      >,\n      initialRouteName: string | undefined\n    ) => {\n      return Object.fromEntries(\n        Object.entries(screens)\n          // Re-order to move the initial route to the front\n          // This way we can detect the initial route correctly\n          .sort(([a], [b]) => {\n            if (a === initialRouteName) {\n              return -1;\n            }\n\n            if (b === initialRouteName) {\n              return 1;\n            }\n\n            return 0;\n          })\n          .map(([key, item]) => {\n            const screenConfig: PathConfig<ParamListBase> = {};\n\n            if ('linking' in item) {\n              if (typeof item.linking === 'string') {\n                screenConfig.path = item.linking;\n              } else {\n                Object.assign(screenConfig, item.linking);\n              }\n\n              if (typeof screenConfig.path === 'string') {\n                screenConfig.path = screenConfig.path\n                  .replace(/^\\//, '') // Remove extra leading slash\n                  .replace(/\\/$/, ''); // Remove extra trailing slash\n              }\n            }\n\n            let screens;\n\n            const skipInitialDetectionInChild =\n              skipInitialDetection ||\n              (screenConfig.path != null && screenConfig.path !== '');\n\n            if ('config' in item) {\n              screens = createPathConfigForTree(\n                item,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            } else if (\n              'screen' in item &&\n              'config' in item.screen &&\n              (item.screen.config.screens || item.screen.config.groups)\n            ) {\n              screens = createPathConfigForTree(\n                item.screen,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            }\n\n            if (screens) {\n              screenConfig.screens = screens;\n            }\n\n            if (\n              auto &&\n              !screenConfig.screens &&\n              // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly\n              !('linking' in item && item.linking == null)\n            ) {\n              if (screenConfig.path != null) {\n                if (!skipInitialDetection && screenConfig.path === '') {\n                  // We encounter a leaf screen with empty path,\n                  // Clear the initial screen config as it's not needed anymore\n                  initialScreenConfig = undefined;\n                }\n              } else {\n                if (!skipInitialDetection && initialScreenConfig == null) {\n                  initialScreenConfig = screenConfig;\n                }\n\n                screenConfig.path = key\n                  .replace(/([A-Z]+)/g, '-$1')\n                  .replace(/^-/, '')\n                  .toLowerCase();\n              }\n            }\n\n            return [key, screenConfig] as const;\n          })\n          .filter(([, screen]) => Object.keys(screen).length > 0)\n      );\n    };\n\n    const screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(\n          screens,\n          createPathConfigForScreens(\n            t.config.screens,\n            o?.initialRouteName ?? t.config.initialRouteName\n          )\n        );\n      }\n\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(\n            screens,\n            createPathConfigForScreens(\n              group.screens,\n              o?.initialRouteName ?? t.config.initialRouteName\n            )\n          );\n        });\n      }\n    }\n\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n\n    return screens;\n  };\n\n  const screens = createPathConfigForTree(tree, options, false);\n\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n\n  return screens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}