{"ast":null,"code":"\"use strict\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}import escape from'escape-string-regexp';import*as queryString from'query-string';import{arrayStartsWith}from\"./arrayStartsWith.js\";import{findFocusedRoute}from\"./findFocusedRoute.js\";import{getPatternParts}from\"./getPatternParts.js\";import{isArrayEqual}from\"./isArrayEqual.js\";import{validatePathConfig}from\"./validatePathConfig.js\";export function getStateFromPath(path,options){var _options$path;var _getConfigResources=getConfigResources(options),initialRoutes=_getConfigResources.initialRoutes,configs=_getConfigResources.configs;var screens=options==null?void 0:options.screens;var remaining=path.replace(/\\/+/g,'/').replace(/^\\//,'').replace(/\\?.*$/,'');remaining=remaining.endsWith('/')?remaining:`${remaining}/`;var prefix=options==null?void 0:(_options$path=options.path)==null?void 0:_options$path.replace(/^\\//,'');if(prefix){var normalizedPrefix=prefix.endsWith('/')?prefix:`${prefix}/`;if(!remaining.startsWith(normalizedPrefix)){return undefined;}remaining=remaining.replace(normalizedPrefix,'');}if(screens===undefined){var _routes=remaining.split('/').filter(Boolean).map(function(segment){var name=decodeURIComponent(segment);return{name:name};});if(_routes.length){return createNestedStateObject(path,_routes,initialRoutes);}return undefined;}if(remaining==='/'){var match=configs.find(function(config){return config.segments.join('/')==='';});if(match){return createNestedStateObject(path,match.routeNames.map(function(name){return{name:name};}),initialRoutes,configs);}return undefined;}var result;var current;var _matchAgainstConfigs=matchAgainstConfigs(remaining,configs),routes=_matchAgainstConfigs.routes,remainingPath=_matchAgainstConfigs.remainingPath;if(routes!==undefined){current=createNestedStateObject(path,routes,initialRoutes,configs);remaining=remainingPath;result=current;}if(current==null||result==null){return undefined;}return result;}var cachedConfigResources=new WeakMap();function getConfigResources(options){if(!options)return prepareConfigResources();var cached=cachedConfigResources.get(options);if(cached)return cached;var resources=prepareConfigResources(options);cachedConfigResources.set(options,resources);return resources;}function prepareConfigResources(options){if(options){validatePathConfig(options);}var initialRoutes=getInitialRoutes(options);var configs=getSortedNormalizedConfigs(initialRoutes,options==null?void 0:options.screens);checkForDuplicatedConfigs(configs);var configWithRegexes=getConfigsWithRegexes(configs);return{initialRoutes:initialRoutes,configs:configs,configWithRegexes:configWithRegexes};}function getInitialRoutes(options){var initialRoutes=[];if(options!=null&&options.initialRouteName){initialRoutes.push({initialRouteName:options.initialRouteName,parentScreens:[]});}return initialRoutes;}function getSortedNormalizedConfigs(initialRoutes){var _ref;var screens=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return(_ref=[]).concat.apply(_ref,_toConsumableArray(Object.keys(screens).map(function(key){return _createNormalizedConfigs(key,screens,initialRoutes,[],[],[]);}))).sort(function(a,b){if(isArrayEqual(a.segments,b.segments)){return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));}if(arrayStartsWith(a.segments,b.segments)){return-1;}if(arrayStartsWith(b.segments,a.segments)){return 1;}for(var i=0;i<Math.max(a.segments.length,b.segments.length);i++){if(a.segments[i]==null){return 1;}if(b.segments[i]==null){return-1;}var aWildCard=a.segments[i]==='*';var bWildCard=b.segments[i]==='*';var aParam=a.segments[i].startsWith(':');var bParam=b.segments[i].startsWith(':');var aRegex=aParam&&a.segments[i].includes('(');var bRegex=bParam&&b.segments[i].includes('(');if(aWildCard&&bWildCard||aRegex&&bRegex){continue;}if(aWildCard&&!bWildCard){return 1;}if(bWildCard&&!aWildCard){return-1;}if(aParam&&!bParam){return 1;}if(bParam&&!aParam){return-1;}if(aRegex&&!bRegex){return-1;}if(bRegex&&!aRegex){return 1;}}return a.segments.length-b.segments.length;});}function checkForDuplicatedConfigs(configs){configs.reduce(function(acc,config){var pattern=config.segments.join('/');if(acc[pattern]){var a=acc[pattern].routeNames;var b=config.routeNames;var intersects=a.length>b.length?b.every(function(it,i){return a[i]===it;}):a.every(function(it,i){return b[i]===it;});if(!intersects){throw new Error(`Found conflicting screens with the same pattern. The pattern '${pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);}}return Object.assign(acc,_defineProperty({},pattern,config));},{});}function getConfigsWithRegexes(configs){return configs.map(function(c){return _objectSpread(_objectSpread({},c),{},{regex:c.regex?new RegExp(c.regex.source+'$'):undefined});});}var matchAgainstConfigs=function matchAgainstConfigs(remaining,configs){var routes;var remainingPath=remaining;var _loop=function _loop(config){if(!config.regex){return 0;}var match=remainingPath.match(config.regex);if(match){routes=config.routeNames.map(function(routeName){var routeConfig=configs.find(function(c){return c.screen===routeName&&arrayStartsWith(config.segments,c.segments);});var params=routeConfig&&match.groups?Object.fromEntries(Object.entries(match.groups).map(function(_ref2){var _ref3=_slicedToArray(_ref2,2),key=_ref3[0],value=_ref3[1];var index=Number(key.replace('param_',''));var param=routeConfig.params.find(function(it){return it.index===index;});if((param==null?void 0:param.screen)===routeName&&param!=null&&param.name){return[param.name,value];}return null;}).filter(function(it){return it!=null;}).map(function(_ref4){var _routeConfig$parse;var _ref5=_slicedToArray(_ref4,2),key=_ref5[0],value=_ref5[1];if(value==null){return[key,undefined];}var decoded=decodeURIComponent(value);var parsed=(_routeConfig$parse=routeConfig.parse)!=null&&_routeConfig$parse[key]?routeConfig.parse[key](decoded):decoded;return[key,parsed];})):undefined;if(params&&Object.keys(params).length){return{name:routeName,params:params};}return{name:routeName};});remainingPath=remainingPath.replace(match[0],'');return 1;}},_ret;for(var config of configs){_ret=_loop(config);if(_ret===0)continue;if(_ret===1)break;}return{routes:routes,remainingPath:remainingPath};};var _createNormalizedConfigs=function createNormalizedConfigs(screen,routeConfig,initials,paths,parentScreens,routeNames){var configs=[];routeNames.push(screen);parentScreens.push(screen);var config=routeConfig[screen];if(typeof config==='string'){paths.push({screen:screen,path:config});configs.push(createConfigItem(screen,_toConsumableArray(routeNames),_toConsumableArray(paths)));}else if(typeof config==='object'){var _config$alias;if(typeof config.path==='string'){if(config.exact&&config.path==null){throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \\`path: ''\\`.`);}var aliasConfigs=[];if(config.alias){for(var alias of config.alias){if(typeof alias==='string'){aliasConfigs.push(createConfigItem(screen,_toConsumableArray(routeNames),[].concat(_toConsumableArray(paths),[{screen:screen,path:alias}]),config.parse));}else if(typeof alias==='object'){aliasConfigs.push(createConfigItem(screen,_toConsumableArray(routeNames),alias.exact?[{screen:screen,path:alias.path}]:[].concat(_toConsumableArray(paths),[{screen:screen,path:alias.path}]),alias.parse));}}}if(config.exact){paths.length=0;}paths.push({screen:screen,path:config.path});configs.push(createConfigItem(screen,_toConsumableArray(routeNames),_toConsumableArray(paths),config.parse));configs.push.apply(configs,aliasConfigs);}if(typeof config!=='string'&&typeof config.path!=='string'&&(_config$alias=config.alias)!=null&&_config$alias.length){throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`);}if(config.screens){if(config.initialRouteName){initials.push({initialRouteName:config.initialRouteName,parentScreens:parentScreens});}Object.keys(config.screens).forEach(function(nestedConfig){var result=_createNormalizedConfigs(nestedConfig,config.screens,initials,_toConsumableArray(paths),_toConsumableArray(parentScreens),routeNames);configs.push.apply(configs,_toConsumableArray(result));});}}routeNames.pop();return configs;};var createConfigItem=function createConfigItem(screen,routeNames,paths,parse){var parts=[];var _loop2=function _loop2(_screen){parts.push.apply(parts,_toConsumableArray(getPatternParts(path).map(function(part){return _objectSpread(_objectSpread({},part),{},{screen:_screen});})));};for(var _ref6 of paths){var _screen=_ref6.screen;var path=_ref6.path;_loop2(_screen);}var regex=parts.length?new RegExp(`^(${parts.map(function(it,i){if(it.param){var reg=it.regex||'[^/]+';return`(((?<param_${i}>${reg})\\\\/)${it.optional?'?':''})`;}return`${it.segment==='*'?'.*':escape(it.segment)}\\\\/`;}).join('')})$`):undefined;var segments=parts.map(function(it){return it.segment;});var params=parts.map(function(it,i){return it.param?{index:i,screen:it.screen,name:it.param}:null;}).filter(function(it){return it!=null;});return{screen:screen,regex:regex,segments:segments,params:params,routeNames:routeNames,parse:parse};};var findParseConfigForRoute=function findParseConfigForRoute(routeName,flatConfig){for(var config of flatConfig){if(routeName===config.routeNames[config.routeNames.length-1]){return config.parse;}}return undefined;};var findInitialRoute=function findInitialRoute(routeName,parentScreens,initialRoutes){for(var config of initialRoutes){if(parentScreens.length===config.parentScreens.length){var sameParents=true;for(var i=0;i<parentScreens.length;i++){if(parentScreens[i].localeCompare(config.parentScreens[i])!==0){sameParents=false;break;}}if(sameParents){return routeName!==config.initialRouteName?config.initialRouteName:undefined;}}}return undefined;};var createStateObject=function createStateObject(initialRoute,route,isEmpty){if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute},route]};}else{return{routes:[route]};}}else{if(initialRoute){return{index:1,routes:[{name:initialRoute},_objectSpread(_objectSpread({},route),{},{state:{routes:[]}})]};}else{return{routes:[_objectSpread(_objectSpread({},route),{},{state:{routes:[]}})]};}}};var createNestedStateObject=function createNestedStateObject(path,routes,initialRoutes,flatConfig){var route=routes.shift();var parentScreens=[];var initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);parentScreens.push(route.name);var state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){var nestedState=state;while(route=routes.shift()){initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);var nestedStateIndex=nestedState.index||nestedState.routes.length-1;nestedState.routes[nestedStateIndex].state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){nestedState=nestedState.routes[nestedStateIndex].state;}parentScreens.push(route.name);}}route=findFocusedRoute(state);route.path=path.replace(/\\/$/,'');var params=parseQueryParams(path,flatConfig?findParseConfigForRoute(route.name,flatConfig):undefined);if(params){route.params=_objectSpread(_objectSpread({},route.params),params);}return state;};var parseQueryParams=function parseQueryParams(path,parseConfig){var query=path.split('?')[1];var params=queryString.parse(query);if(parseConfig){Object.keys(params).forEach(function(name){if(Object.hasOwnProperty.call(parseConfig,name)&&typeof params[name]==='string'){params[name]=parseConfig[name](params[name]);}});}return Object.keys(params).length?params:undefined;};","map":{"version":3,"names":["escape","queryString","arrayStartsWith","findFocusedRoute","getPatternParts","isArrayEqual","validatePathConfig","getStateFromPath","path","options","_options$path","_getConfigResources","getConfigResources","initialRoutes","configs","screens","remaining","replace","endsWith","prefix","normalizedPrefix","startsWith","undefined","routes","split","filter","Boolean","map","segment","name","decodeURIComponent","length","createNestedStateObject","match","find","config","segments","join","routeNames","result","current","_matchAgainstConfigs","matchAgainstConfigs","remainingPath","cachedConfigResources","WeakMap","prepareConfigResources","cached","get","resources","set","getInitialRoutes","getSortedNormalizedConfigs","checkForDuplicatedConfigs","configWithRegexes","getConfigsWithRegexes","initialRouteName","push","parentScreens","_ref","arguments","concat","apply","_toConsumableArray","Object","keys","key","createNormalizedConfigs","sort","a","b","localeCompare","i","Math","max","aWildCard","bWildCard","aParam","bParam","aRegex","includes","bRegex","reduce","acc","pattern","intersects","every","it","Error","assign","_defineProperty","c","_objectSpread","regex","RegExp","source","_loop","routeName","routeConfig","screen","params","groups","fromEntries","entries","_ref2","_ref3","_slicedToArray","value","index","Number","param","_ref4","_routeConfig$parse","_ref5","decoded","parsed","parse","_ret","initials","paths","createConfigItem","_config$alias","exact","aliasConfigs","alias","forEach","nestedConfig","pop","parts","_loop2","_screen","part","_ref6","reg","optional","findParseConfigForRoute","flatConfig","findInitialRoute","sameParents","createStateObject","initialRoute","route","isEmpty","state","shift","nestedState","nestedStateIndex","parseQueryParams","parseConfig","query","hasOwnProperty","call"],"sources":["/Users/yuezhang/Documents/projects/gongzhu/GongzhuGUI/node_modules/@react-navigation/core/src/getStateFromPath.tsx"],"sourcesContent":["import type {\n  InitialState,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n} from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\n\nimport { arrayStartsWith } from './arrayStartsWith';\nimport { findFocusedRoute } from './findFocusedRoute';\nimport { getPatternParts, type PatternPart } from './getPatternParts';\nimport { isArrayEqual } from './isArrayEqual';\nimport type { PathConfig, PathConfigMap } from './types';\nimport { validatePathConfig } from './validatePathConfig';\n\ntype Options<ParamList extends {}> = {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => unknown>;\n\ntype RouteConfig = {\n  screen: string;\n  regex?: RegExp;\n  segments: string[];\n  params: { screen: string; name?: string; index: number }[];\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, unknown> | undefined;\n};\n\ntype ConfigResources = {\n  initialRoutes: InitialRouteConfig[];\n  configs: RouteConfig[];\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport function getStateFromPath<ParamList extends {}>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  const { initialRoutes, configs } = getConfigResources(options);\n\n  const screens = options?.screens;\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  const prefix = options?.path?.replace(/^\\//, ''); // Remove extra leading slash\n\n  if (prefix) {\n    // Make sure there is a trailing slash\n    const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;\n\n    // If the path doesn't start with the prefix, it's not a match\n    if (!remaining.startsWith(normalizedPrefix)) {\n      return undefined;\n    }\n\n    // Remove the prefix from the path\n    remaining = remaining.replace(normalizedPrefix, '');\n  }\n\n  if (screens === undefined) {\n    // When no config is specified, use the path segments as route names\n    const routes = remaining\n      .split('/')\n      .filter(Boolean)\n      .map((segment) => {\n        const name = decodeURIComponent(segment);\n        return { name };\n      });\n\n    if (routes.length) {\n      return createNestedStateObject(path, routes, initialRoutes);\n    }\n\n    return undefined;\n  }\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find((config) => config.segments.join('/') === '');\n\n    if (match) {\n      return createNestedStateObject(\n        path,\n        match.routeNames.map((name) => ({ name })),\n        initialRoutes,\n        configs\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const { routes, remainingPath } = matchAgainstConfigs(remaining, configs);\n\n  if (routes !== undefined) {\n    // This will always be empty if full path matched\n    current = createNestedStateObject(path, routes, initialRoutes, configs);\n    remaining = remainingPath;\n    result = current;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  return result;\n}\n\n/**\n * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.\n */\nconst cachedConfigResources = new WeakMap<Options<{}>, ConfigResources>();\n\nfunction getConfigResources<ParamList extends {}>(\n  options: Options<ParamList> | undefined\n) {\n  if (!options) return prepareConfigResources();\n\n  const cached = cachedConfigResources.get(options);\n\n  if (cached) return cached;\n\n  const resources = prepareConfigResources(options);\n\n  cachedConfigResources.set(options, resources);\n\n  return resources;\n}\n\nfunction prepareConfigResources(options?: Options<{}>) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const initialRoutes = getInitialRoutes(options);\n  const configs = getSortedNormalizedConfigs(initialRoutes, options?.screens);\n\n  checkForDuplicatedConfigs(configs);\n\n  const configWithRegexes = getConfigsWithRegexes(configs);\n\n  return {\n    initialRoutes,\n    configs,\n    configWithRegexes,\n  };\n}\n\nfunction getInitialRoutes(options?: Options<{}>) {\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  return initialRoutes;\n}\n\nfunction getSortedNormalizedConfigs(\n  initialRoutes: InitialRouteConfig[],\n  screens: Record<string, string | PathConfig<ParamListBase>> = {}\n) {\n  // Create a normalized configs array which will be easier to use\n  return ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(screens).map((key) =>\n        createNormalizedConfigs(key, screens, initialRoutes, [], [], [])\n      )\n    )\n    .sort((a, b) => {\n      // Sort config from most specific to least specific:\n      // - more segments\n      // - static segments\n      // - params with regex\n      // - regular params\n      // - wildcard\n\n      // If 2 patterns are same, move the one with less route names up\n      // This is an error state, so it's only useful for consistent error messages\n      if (isArrayEqual(a.segments, b.segments)) {\n        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n      }\n\n      // If one of the patterns starts with the other, it's more exhaustive\n      // So move it up\n      if (arrayStartsWith(a.segments, b.segments)) {\n        return -1;\n      }\n\n      if (arrayStartsWith(b.segments, a.segments)) {\n        return 1;\n      }\n\n      for (let i = 0; i < Math.max(a.segments.length, b.segments.length); i++) {\n        // if b is longer, b gets higher priority\n        if (a.segments[i] == null) {\n          return 1;\n        }\n\n        // if a is longer, a gets higher priority\n        if (b.segments[i] == null) {\n          return -1;\n        }\n\n        const aWildCard = a.segments[i] === '*';\n        const bWildCard = b.segments[i] === '*';\n        const aParam = a.segments[i].startsWith(':');\n        const bParam = b.segments[i].startsWith(':');\n        const aRegex = aParam && a.segments[i].includes('(');\n        const bRegex = bParam && b.segments[i].includes('(');\n\n        // if both are wildcard or regex, we compare next component\n        if ((aWildCard && bWildCard) || (aRegex && bRegex)) {\n          continue;\n        }\n\n        // if only a is wildcard, b gets higher priority\n        if (aWildCard && !bWildCard) {\n          return 1;\n        }\n\n        // if only b is wildcard, a gets higher priority\n        if (bWildCard && !aWildCard) {\n          return -1;\n        }\n\n        // If only a has a param, b gets higher priority\n        if (aParam && !bParam) {\n          return 1;\n        }\n\n        // If only b has a param, a gets higher priority\n        if (bParam && !aParam) {\n          return -1;\n        }\n\n        // if only a has regex, a gets higher priority\n        if (aRegex && !bRegex) {\n          return -1;\n        }\n\n        // if only b has regex, b gets higher priority\n        if (bRegex && !aRegex) {\n          return 1;\n        }\n      }\n\n      return a.segments.length - b.segments.length;\n    });\n}\n\nfunction checkForDuplicatedConfigs(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    const pattern = config.segments.join('/');\n\n    if (acc[pattern]) {\n      const a = acc[pattern].routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length\n          ? b.every((it, i) => a[i] === it)\n          : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        throw new Error(\n          `Found conflicting screens with the same pattern. The pattern '${\n            pattern\n          }' resolves to both '${a.join(' > ')}' and '${b.join(\n            ' > '\n          )}'. Patterns must be unique and cannot resolve to more than one screen.`\n        );\n      }\n    }\n\n    return Object.assign(acc, {\n      [pattern]: config,\n    });\n  }, {});\n}\n\nfunction getConfigsWithRegexes(configs: RouteConfig[]) {\n  return configs.map((c) => ({\n    ...c,\n    // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n    regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n  }));\n}\n\nconst matchAgainstConfigs = (remaining: string, configs: RouteConfig[]) => {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (match) {\n      routes = config.routeNames.map((routeName) => {\n        const routeConfig = configs.find((c) => {\n          // Check matching name AND pattern in case same screen is used at different levels in config\n          return (\n            c.screen === routeName &&\n            arrayStartsWith(config.segments, c.segments)\n          );\n        });\n\n        const params =\n          routeConfig && match.groups\n            ? Object.fromEntries(\n                Object.entries(match.groups)\n                  .map(([key, value]) => {\n                    const index = Number(key.replace('param_', ''));\n                    const param = routeConfig.params.find(\n                      (it) => it.index === index\n                    );\n\n                    if (param?.screen === routeName && param?.name) {\n                      return [param.name, value];\n                    }\n\n                    return null;\n                  })\n                  .filter((it) => it != null)\n                  .map(([key, value]) => {\n                    if (value == null) {\n                      return [key, undefined];\n                    }\n\n                    const decoded = decodeURIComponent(value);\n                    const parsed = routeConfig.parse?.[key]\n                      ? routeConfig.parse[key](decoded)\n                      : decoded;\n\n                    return [key, parsed];\n                  })\n              )\n            : undefined;\n\n        if (params && Object.keys(params).length) {\n          return { name: routeName, params };\n        }\n\n        return { name: routeName };\n      });\n\n      remainingPath = remainingPath.replace(match[0], '');\n\n      break;\n    }\n  }\n\n  return { routes, remainingPath };\n};\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: Record<string, string | PathConfig<ParamListBase>>,\n  initials: InitialRouteConfig[],\n  paths: { screen: string; path: string }[],\n  parentScreens: string[],\n  routeNames: string[]\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    paths.push({ screen, path: config });\n    configs.push(createConfigItem(screen, [...routeNames], [...paths]));\n  } else if (typeof config === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path == null) {\n        throw new Error(\n          `Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \\`path: ''\\`.`\n        );\n      }\n\n      // We should add alias configs after the main config\n      // So unless they are more specific, main config will be matched first\n      const aliasConfigs = [];\n\n      if (config.alias) {\n        for (const alias of config.alias) {\n          if (typeof alias === 'string') {\n            aliasConfigs.push(\n              createConfigItem(\n                screen,\n                [...routeNames],\n                [...paths, { screen, path: alias }],\n                config.parse\n              )\n            );\n          } else if (typeof alias === 'object') {\n            aliasConfigs.push(\n              createConfigItem(\n                screen,\n                [...routeNames],\n                alias.exact\n                  ? [{ screen, path: alias.path }]\n                  : [...paths, { screen, path: alias.path }],\n                alias.parse\n              )\n            );\n          }\n        }\n      }\n\n      if (config.exact) {\n        // If it's an exact path, we don't need to keep track of the parent screens\n        // So we can clear it\n        paths.length = 0;\n      }\n\n      paths.push({ screen, path: config.path });\n      configs.push(\n        createConfigItem(screen, [...routeNames], [...paths], config.parse)\n      );\n\n      configs.push(...aliasConfigs);\n    }\n\n    if (\n      typeof config !== 'string' &&\n      typeof config.path !== 'string' &&\n      config.alias?.length\n    ) {\n      throw new Error(\n        `Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as Record<string, string | PathConfig<ParamListBase>>,\n          initials,\n          [...paths],\n          [...parentScreens],\n          routeNames\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  paths: { screen: string; path: string }[],\n  parse?: ParseConfig\n): RouteConfig => {\n  const parts: (PatternPart & { screen: string })[] = [];\n\n  // Parse the path string into parts for easier matching\n  for (const { screen, path } of paths) {\n    parts.push(...getPatternParts(path).map((part) => ({ ...part, screen })));\n  }\n\n  const regex = parts.length\n    ? new RegExp(\n        `^(${parts\n          .map((it, i) => {\n            if (it.param) {\n              const reg = it.regex || '[^/]+';\n\n              return `(((?<param_${i}>${reg})\\\\/)${it.optional ? '?' : ''})`;\n            }\n\n            return `${it.segment === '*' ? '.*' : escape(it.segment)}\\\\/`;\n          })\n          .join('')})$`\n      )\n    : undefined;\n\n  const segments = parts.map((it) => it.segment);\n  const params = parts\n    .map((it, i) =>\n      it.param\n        ? {\n            index: i,\n            screen: it.screen,\n            name: it.param,\n          }\n        : null\n    )\n    .filter((it) => it != null);\n\n  return {\n    screen,\n    regex,\n    segments,\n    params,\n    routeNames,\n    parse,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (parentScreens.length === config.parentScreens.length) {\n      let sameParents = true;\n      for (let i = 0; i < parentScreens.length; i++) {\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n          sameParents = false;\n          break;\n        }\n      }\n      if (sameParents) {\n        return routeName !== config.initialRouteName\n          ? config.initialRouteName\n          : undefined;\n      }\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    } else {\n      return {\n        routes: [route],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n      };\n    } else {\n      return {\n        routes: [{ ...route, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  initialRoutes: InitialRouteConfig[],\n  flatConfig?: RouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(\n    initialRoute,\n    route,\n    routes.length === 0\n  );\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n  route.path = path.replace(/\\/$/, '');\n\n  const params = parseQueryParams(\n    path,\n    flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (\n  path: string,\n  parseConfig?: Record<string, (value: string) => unknown>\n) => {\n  const query = path.split('?')[1];\n  const params: Record<string, unknown> = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (\n        Object.hasOwnProperty.call(parseConfig, name) &&\n        typeof params[name] === 'string'\n      ) {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}