{"ast":null,"code":"\"use strict\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}var formatToList=function formatToList(items){return Object.entries(items).map(function(_ref){var _ref2=_slicedToArray(_ref,2),key=_ref2[0],value=_ref2[1];return`- ${key} (${value})`;}).join('\\n');};export function validatePathConfig(config){var root=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var validation=_objectSpread({path:'string',initialRouteName:'string',screens:'object'},root?null:{alias:'array',exact:'boolean',stringify:'object',parse:'object'});if(typeof config!=='object'||config===null){throw new Error(`Expected the configuration to be an object, but got ${JSON.stringify(config)}.`);}var validationErrors=Object.fromEntries(Object.keys(config).map(function(key){if(key in validation){var type=validation[key];var value=config[key];if(value!==undefined){if(type==='array'){if(!Array.isArray(value)){return[key,`expected 'Array', got '${typeof value}'`];}}else if(typeof value!==type){return[key,`expected '${type}', got '${typeof value}'`];}}}else{return[key,'extraneous'];}return null;}).filter(Boolean));if(Object.keys(validationErrors).length){throw new Error(`Found invalid properties in the configuration:\\n${formatToList(validationErrors)}\\n\\nYou can only specify the following properties:\\n${formatToList(validation)}\\n\\nIf you want to specify configuration for screens, you need to specify them under a 'screens' property.\\n\\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);}if(root&&'path'in config&&typeof config.path==='string'&&config.path.includes(':')){throw new Error(`Found invalid path '${config.path}'. The 'path' in the top-level configuration cannot contain patterns for params.`);}if('screens'in config&&config.screens){Object.entries(config.screens).forEach(function(_ref3){var _ref4=_slicedToArray(_ref3,2),_=_ref4[0],value=_ref4[1];if(typeof value!=='string'){validatePathConfig(value,false);}});}}","map":{"version":3,"names":["formatToList","items","Object","entries","map","_ref","_ref2","_slicedToArray","key","value","join","validatePathConfig","config","root","arguments","length","undefined","validation","_objectSpread","path","initialRouteName","screens","alias","exact","stringify","parse","Error","JSON","validationErrors","fromEntries","keys","type","Array","isArray","filter","Boolean","includes","forEach","_ref3","_ref4","_"],"sources":["/Users/yuezhang/Documents/projects/gongzhu/GongzhuGUI/node_modules/@react-navigation/core/src/validatePathConfig.tsx"],"sourcesContent":["const formatToList = (items: Record<string, string>) =>\n  Object.entries(items)\n    .map(([key, value]) => `- ${key} (${value})`)\n    .join('\\n');\n\nexport function validatePathConfig(config: unknown, root = true) {\n  const validation = {\n    path: 'string',\n    initialRouteName: 'string',\n    screens: 'object',\n    ...(root\n      ? null\n      : {\n          alias: 'array',\n          exact: 'boolean',\n          stringify: 'object',\n          parse: 'object',\n        }),\n  };\n\n  if (typeof config !== 'object' || config === null) {\n    throw new Error(\n      `Expected the configuration to be an object, but got ${JSON.stringify(\n        config\n      )}.`\n    );\n  }\n\n  const validationErrors = Object.fromEntries(\n    Object.keys(config)\n      .map((key) => {\n        if (key in validation) {\n          const type = validation[key as keyof typeof validation];\n          // @ts-expect-error: we know the key exists\n          const value = config[key];\n\n          if (value !== undefined) {\n            if (type === 'array') {\n              if (!Array.isArray(value)) {\n                return [key, `expected 'Array', got '${typeof value}'`];\n              }\n            } else if (typeof value !== type) {\n              return [key, `expected '${type}', got '${typeof value}'`];\n            }\n          }\n        } else {\n          return [key, 'extraneous'];\n        }\n\n        return null;\n      })\n      .filter(Boolean) as [string, string][]\n  );\n\n  if (Object.keys(validationErrors).length) {\n    throw new Error(\n      `Found invalid properties in the configuration:\\n${formatToList(\n        validationErrors\n      )}\\n\\nYou can only specify the following properties:\\n${formatToList(\n        validation\n      )}\\n\\nIf you want to specify configuration for screens, you need to specify them under a 'screens' property.\\n\\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`\n    );\n  }\n\n  if (\n    root &&\n    'path' in config &&\n    typeof config.path === 'string' &&\n    config.path.includes(':')\n  ) {\n    throw new Error(\n      `Found invalid path '${config.path}'. The 'path' in the top-level configuration cannot contain patterns for params.`\n    );\n  }\n\n  if ('screens' in config && config.screens) {\n    Object.entries(config.screens).forEach(([_, value]) => {\n      if (typeof value !== 'string') {\n        validatePathConfig(value, false);\n      }\n    });\n  }\n}\n"],"mappings":"6vBAAA,GAAM,CAAAA,YAAY,CAAI,QAAhB,CAAAA,YAAYA,CAAIC,KAA6B,QACjD,CAAAC,MAAM,CAACC,OAAO,CAACF,KAAK,CAAC,CAClBG,GAAG,CAAC,SAAAC,IAAA,MAAAC,KAAA,CAAAC,cAAA,CAAAF,IAAA,IAAEG,GAAG,CAAAF,KAAA,IAAEG,KAAK,CAAAH,KAAA,UAAM,KAAKE,GAAG,KAAKC,KAAK,GAAG,GAAC,CAC5CC,IAAI,CAAC,IAAI,CAAC,GAEf,MAAO,SAAS,CAAAC,kBAAkBA,CAACC,MAAe,CAAe,IAAb,CAAAC,IAAI,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,IAAI,CAC7D,GAAM,CAAAG,UAAU,CAAAC,aAAA,EACdC,IAAI,CAAE,QAAQ,CACdC,gBAAgB,CAAE,QAAQ,CAC1BC,OAAO,CAAE,QAAQ,EACbR,IAAI,CACJ,IAAI,CACJ,CACES,KAAK,CAAE,OAAO,CACdC,KAAK,CAAE,SAAS,CAChBC,SAAS,CAAE,QAAQ,CACnBC,KAAK,CAAE,QACT,CAAC,CACN,CAED,GAAI,MAAO,CAAAb,MAAM,GAAK,QAAQ,EAAIA,MAAM,GAAK,IAAI,CAAE,CACjD,KAAM,IAAI,CAAAc,KAAK,CACb,uDAAuDC,IAAI,CAACH,SAAS,CACnEZ,MACF,CAAC,GACH,CAAC,CACH,CAEA,GAAM,CAAAgB,gBAAgB,CAAG1B,MAAM,CAAC2B,WAAW,CACzC3B,MAAM,CAAC4B,IAAI,CAAClB,MAAM,CAAC,CAChBR,GAAG,CAAE,SAAAI,GAAG,CAAK,CACZ,GAAIA,GAAG,GAAI,CAAAS,UAAU,CAAE,CACrB,GAAM,CAAAc,IAAI,CAAGd,UAAU,CAACT,GAAG,CAA4B,CAEvD,GAAM,CAAAC,KAAK,CAAGG,MAAM,CAACJ,GAAG,CAAC,CAEzB,GAAIC,KAAK,GAAKO,SAAS,CAAE,CACvB,GAAIe,IAAI,GAAK,OAAO,CAAE,CACpB,GAAI,CAACC,KAAK,CAACC,OAAO,CAACxB,KAAK,CAAC,CAAE,CACzB,MAAO,CAACD,GAAG,CAAE,0BAA0B,MAAO,CAAAC,KAAK,GAAG,CAAC,CACzD,CACF,CAAC,IAAM,IAAI,MAAO,CAAAA,KAAK,GAAKsB,IAAI,CAAE,CAChC,MAAO,CAACvB,GAAG,CAAE,aAAauB,IAAI,WAAW,MAAO,CAAAtB,KAAK,GAAG,CAAC,CAC3D,CACF,CACF,CAAC,IAAM,CACL,MAAO,CAACD,GAAG,CAAE,YAAY,CAAC,CAC5B,CAEA,MAAO,KAAI,CACb,CAAC,CAAC,CACD0B,MAAM,CAACC,OAAO,CACnB,CAAC,CAED,GAAIjC,MAAM,CAAC4B,IAAI,CAACF,gBAAgB,CAAC,CAACb,MAAM,CAAE,CACxC,KAAM,IAAI,CAAAW,KAAK,CACb,mDAAmD1B,YAAY,CAC7D4B,gBACF,CAAC,uDAAuD5B,YAAY,CAClEiB,UACF,CAAC,kOACH,CAAC,CACH,CAEA,GACEJ,IAAI,EACJ,MAAM,EAAI,CAAAD,MAAM,EAChB,MAAO,CAAAA,MAAM,CAACO,IAAI,GAAK,QAAQ,EAC/BP,MAAM,CAACO,IAAI,CAACiB,QAAQ,CAAC,GAAG,CAAC,CACzB,CACA,KAAM,IAAI,CAAAV,KAAK,CACb,uBAAuBd,MAAM,CAACO,IAAI,kFACpC,CAAC,CACH,CAEA,GAAI,SAAS,EAAI,CAAAP,MAAM,EAAIA,MAAM,CAACS,OAAO,CAAE,CACzCnB,MAAM,CAACC,OAAO,CAACS,MAAM,CAACS,OAAO,CAAC,CAACgB,OAAO,CAAC,SAAAC,KAAA,CAAgB,KAAAC,KAAA,CAAAhC,cAAA,CAAA+B,KAAA,IAAdE,CAAC,CAAAD,KAAA,IAAE9B,KAAK,CAAA8B,KAAA,IAC/C,GAAI,MAAO,CAAA9B,KAAK,GAAK,QAAQ,CAAE,CAC7BE,kBAAkB,CAACF,KAAK,CAAE,KAAK,CAAC,CAClC,CACF,CAAC,CAAC,CACJ,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}